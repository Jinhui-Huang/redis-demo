## 多级缓存

**传统缓存的问题**

传统的缓存策略一般是请求到达Tomcat后, 先查询Redis, 如果未命中则查询数据库, 存在下面几个问题:

- 请求要经过Tomcat处理, Tomcat的性能成为整个系统的瓶颈
- Redis缓存失效时, 会对数据库产生冲击

**多级缓存就是充分利用请求处理的每个环节, 分别添加缓存, 减轻Tomcat压力, 提升服务性能:**

![image-20231109154951697](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231109154951697.png)

用作缓存的Nginx是业务Nginx, 需要部署为集群, 再由专门的Nginx用来做反向代理:

![image-20231109155531978](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231109155531978.png)

### 1. JVM进程缓存

#### (1). 本地进程缓存

如HashMap, GuavaCache;

- 优点: 读取本地内存, 没有网络开销, 速度更快
- 缺点: 存储容量有限, 可靠性较低, 无法共享
- 场景: 性能要求较高, 缓存数据量较小

**Caffeine**是一个基于java8开发的, 提供了近乎最佳命中率的高性能的本地缓存库. 目前Spring内部的缓存使用的就是Caffeine. GitHub地址: [Caffine](http://github.com/ben-manes/caffeine)

测试类:

``````java
@Slf4j
public class CaffeineTest {

    @Test
    void name() {
        /*构建cache对象*/
        Cache<String, String> cache = Caffeine.newBuilder().build();

        /*存数据*/
        cache.put("gf", "胡桃");

        /*取数据*/

        String gf = cache.getIfPresent("gf");
        System.out.println("gf = " + gf);

        /*取数据, 如果未命中, 则查询数据库*/
        String defaultGF = cache.get("default", key -> "芙芙");
        System.out.println("defaultGF = " + defaultGF);
    }
}
``````

**Caffeine的三种缓存驱逐策略:**

- 基于容量: 设置缓存的数量上限

  ``````
  // 创建缓存对象
  Cache<String, String> cahce = Caffiene.newBuilder()
  		.maximumSize(1) //设置缓存大小上限为 1
  		.build();
  ``````

- 基于时间: 设置缓存的有效时间

  ``````
  // 创建缓存对象
  Cache<String, String> cahce = Caffiene.newBuilder()
  		.expireAfterWrite(Duration.ofSeconds(10)) //设置缓存有效期 10 秒, 从最后一次写入开始计时
  		.build();
  ``````

- 基于引用: 设置缓存为软引用或弱引用, 利用GC来回收缓存数据. 性能较差, 不建议使用

在默认情况下, 当一个缓存元素过期时, Caffeine不会自动立即将其清理和驱逐. 而是在一次读或写操作后, 或者在空闲时间完成对失效数据的驱逐

测试类:

``````java
@Slf4j
public class CaffeineTest {
	/**
     * Description: testEvictByNum 基于大小设置驱逐策略：
     * @return void
     * @author jinhui-huang
     * @Date 2023/11/11
     * */
    @Test
    void testEvictByNum() throws InterruptedException {
        // 创建缓存对象
        Cache<String, String> cache = Caffeine.newBuilder()
                // 设置缓存大小上限为 1
                .maximumSize(1)
                .build();
        // 存数据
        cache.put("gf1", "柳岩");
        cache.put("gf2", "范冰冰");
        cache.put("gf3", "迪丽热巴");
        // 延迟10ms，给清理线程一点时间
        Thread.sleep(10L);
        // 获取数据
        System.out.println("gf1: " + cache.getIfPresent("gf1"));
        System.out.println("gf2: " + cache.getIfPresent("gf2"));
        System.out.println("gf3: " + cache.getIfPresent("gf3"));
    }

    /**
     * Description: testEvictByTime 基于时间设置驱逐策略：
     * @return void
     * @author jinhui-huang
     * @Date 2023/11/11
     * */
    @Test
    void testEvictByTime() throws InterruptedException {
        // 创建缓存对象
        Cache<String, String> cache = Caffeine.newBuilder()
                .expireAfterWrite(Duration.ofSeconds(1)) // 设置缓存有效期为 1 秒
                .build();
        // 存数据
        cache.put("gf", "柳岩");
        // 获取数据
        System.out.println("gf: " + cache.getIfPresent("gf"));
        // 休眠一会儿
        Thread.sleep(1200L);
        System.out.println("gf: " + cache.getIfPresent("gf"));
    }
}
``````



#### (2). 实现本地进程缓存

利用Caffeine实现下列需求:

- 给根据id查询商品的业务添加缓存, 缓存未命中时查询数据库
- 给根据id查询商品库存的业务添加缓存, 缓存未命中时查询数据库
- 缓存初识大小为100
- 缓存上限为10000

代码实现:

``````java
public class Demo{
    
	@GetMapping("/{id}")
    public Item findById(@PathVariable("id") Long id){
       return itemCache.get(id, key -> itemService.query()
               .ne("status", 3).eq("id", id)
               .one()
       );
    }

    @GetMapping("/stock/{id}")
    public ItemStock findStockById(@PathVariable("id") Long id){
        return stockCache.get(id, key -> stockService.getById(id));
    }
        
}
``````



### 2. Lua语法入门

#### (1). 初识Lua

Lua是一种轻量小巧的脚本语言, 用标准C语言编写并以源代码形式开放, 其设计目的是为了嵌入式应用程序中, 从而为应用程序提供灵活的扩展和定制功能.

``````lua
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by huian.
--- DateTime: 2023/11/11 下午2:26
---
print("hello world!")
``````



#### (2). 变量和循环

**变量:**

![image-20231111142937164](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231111142937164.png)

![image-20231111143607526](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231111143607526.png)

``````lua
-- 声明字符串
local str1 = 'hello'
local str2 = 'world'
print(str1 .. str2)

-- 声明数组 key为索引的table
local arr = {'java', 'python', 'lua'}
-- lua数组角标从1开始
print(arr[1])

-- 声明table 访问table
local map = {name='Jack', age=21}
print(map['name'])
print(map.name)
``````

**循环:**

![image-20231111145259979](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231111145259979.png)

``````lua
-- 声明数组
local arr = {'java', 'python', 'lua'}
-- 变量数组
for index, value in ipairs(arr) do
    print(index, value)
end
``````



#### (3). 条件控制, 函数

**函数:**

![image-20231111145731226](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231111145731226.png)

**条件控制:**

![image-20231111150116583](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231111150116583.png)

![image-20231111150210433](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231111150210433.png)

``````lua
-- 声明map
local map = {name='Jack', age=21}
-- 声明打印方法
local function printMap(map)
    if (not map) then
        print("table不能为空")
        return nil
    else
        for key, value in pairs(map) do
            print(key, value)
        end
    end
end

printMap(map)
``````



### 3. 多级缓存

#### (1). 安装OpenResty

OpenResty 是一个基于Nginx的高性能Web平台, 用于方便地搭建能够处理高并发, 扩展性极高的动态Web应用, Web服务和动态网关. 具备以下特点:

- 具备Nginx的完整功能
- 基于Lua语言进行扩展, 集成了大量精良的Lua库, 第三方模块
- 允许使用Lua自定义业务逻辑, 自定义库



#### (2). OpenResty快速入门

1. 在nginx.conf的http下面, 添加对OpenResty的Lua模块加载

``````cmd
#lua 模块
lua_package_path "/usr/local/openresty/lualib/?.lua;;";
#c模块     
lua_package_cpath "/usr/local/openresty/lualib/?.so;;";  
``````

2. 在nginx.conf的server下面, 添加对/api/item这个路径的监听

``````cmd
location /api/item {
	# 响应类型, 返回json
	default_type application/json;
	# 响应数据由 lua/item.lua这个文件决定
	content_by_lua_file lua/item.lua;
}
``````



#### (3). 请求参数处理

![image-20231112152849436](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231112152849436.png)



#### (4). 查询Tomcat

**获取请求路径中的商品id信息, 根据id向Tomcat查询商品信息**

1. 获取请求参数中的id
2. 根据id向Tomcat服务发送请求, 查询商品信息
3. 根据id向Tomcat服务发送请求, 查询库存信息
4. 组装商品信息, 库存信息, 序列化为JSON格式并返回

**nginx内部发送Http请求**

``````lua
local resp = ngx.location.capture("/path", {
        method = ngx.HTTP_GET, -- 请求方式
        args = {a=1, b=2}, -- get方式传参数
        body = "c=3&d=4" -- post方式传参数
})
``````

返回的响应内容包括:

- resp.status: 响应状态码
- resp.header: 响应头, 是一个table
- resp.body: 响应体, 就是响应数据

**注意:**这里的path是路径, 并不包括IP和端口. 这个请求会被nginx内部的server监听并处理

但是我们希望这个请求发送daoTomcat服务器上, 所以还需要编写一个server来对这个路径做反向代理:

``````cmd
location /path {
	# tomcat 服务器ip和端口
	proxy_pass http://192.168.43.33:10086
}
``````

**common.lua**

``````lua
-- 封装函数，发送http请求，并解析响应
local function read_http(path, params, requestMethod)
    local resp = ngx.location.capture(path,{
        method = requestMethod,
        args = params,
    })
    if not resp then
        -- 记录错误信息，返回404
        ngx.log(ngx.ERR, "http查询失败, path: ", path , ", args: ", args)
        ngx.exit(404)
    end
    return resp.body
end
-- 将方法导出
local _M = {  
    read_http = read_http
}  
return _M
``````

**查询商品库item.lua**

``````lua
-- 导入common库
local common =require('common')
local read_http = common.read_http
-- 导入cjson库
local cjson = require('cjson')

-- 获取路径参数
local id = ngx.var[1]

-- 查询商品信息
local itemJson = read_http("/items/" .. id, nil, ngx.HTTP_GET)
-- 查询库存信息
local stockJson = read_http("/items/stock/" .. id, nil, ngx.HTTP_GET)

-- JSON 转化为lua的table
local item = cjson.decode(itemJson)
local stock = cjson.decode(stockJson)

-- 组合数据
item.stock = stock.stock
item.sold = stock.sold

-- 把item序列化为json, 返回结果
ngx.say(cjson.encode(item))
``````



**Tomcat集群的负载均衡:**

![image-20231112173708073](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231112173708073.png)

``````cmd
upstream tomcat-cluster {
	hash $request_uri; # 让请求地址只负载到特定的服务器上
	server 192.168.150.1:8081;
	server 192.168.150.1:8082;
}
``````



#### (5). Redis缓存预热

**冷启动:** 服务刚刚启动时, Redis中并没有缓存, 如果所有商品数据都在第一次查询时添加缓存, 可能会给数据库带来较大压力.

**缓存预热:** 在实际开发中, 我们可以利用大数据统计用户访问的热点数据, 在项目启动时将这些热点数据提前查询并保存到Redis中.

``````java
@Component
public class RedisHandler implements InitializingBean {

    @Resource
    private StringRedisTemplate stringRedisTemplate;
    @Resource
    private ItemService itemService;
    @Resource
    private ItemStockService itemStockService;

    private static final ObjectMapper MAPPER = new ObjectMapper();

    @Override
    public void afterPropertiesSet() throws Exception {
        /*初始化缓存*/
        /*1. 查询商品信息*/
        List<Item> items = itemService.list();
        for (Item item : items) {
            /*2.1. item序列化为jsons*/
            String itemJson = MAPPER.writeValueAsString(item);
            /*2. 放入Redis缓存*/
            stringRedisTemplate.opsForValue().set("item:id:" + item.getId(), itemJson);
        }
        /*3. 查询库存信息*/
        List<ItemStock> itemStocks = itemStockService.list();
        for (ItemStock itemStock : itemStocks) {
            /*3.1. item序列化为jsons*/
            String itemStockJson = MAPPER.writeValueAsString(itemStock);
            /*4. 放入Redis缓存*/
            stringRedisTemplate.opsForValue().set("item:stock:id:" + itemStock.getId(), itemStockJson);
        }
    }
}

``````



#### (6). 查询Redis缓存

![image-20231112210229502](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231112210229502.png)

释放Redis连接API：

```lua
-- 关闭redis连接的工具方法，其实是放入连接池
local function close_redis(red)
    local pool_max_idle_time = 10000 -- 连接的空闲时间，单位是毫秒
    local pool_size = 100 --连接池大小
    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)
    if not ok then
        ngx.log(ngx.ERR, "放入redis连接池失败: ", err)
    end
end
```

读取Redis数据的API：

```lua
-- 查询redis的方法 ip和port是redis地址，key是查询的key
local function read_redis(ip, port, key)
    -- 获取一个连接
    local ok, err = red:connect(ip, port)
    if not ok then
        ngx.log(ngx.ERR, "连接redis失败 : ", err)
        return nil
    end
    -- 查询redis
    local resp, err = red:get(key)
    -- 查询失败处理
    if not resp then
        ngx.log(ngx.ERR, "查询Redis失败: ", err, ", key = " , key)
    end
    --得到的数据为空处理
    if resp == ngx.null then
        resp = nil
        ngx.log(ngx.ERR, "查询Redis数据为空, key = ", key)
    end
    close_redis(red)
    return resp
end
```

**查询商品时, 优先Redis缓存查询**

需求:

- 修改item.lua, 封装一个函数read_data, 实现先查询Redis, 如果未命中, 再查询tomcat
- 修改item.lua, 查询商品和库存时都调用read_data这个函数

``````lua
-- 导入common库
local common = require('common')
local read_http = common.read_http
-- local read_redis = common.read_redis
local read_redis_cluster = common.read_redis_cluster
-- 导入cjson库
local cjson = require('cjson')

-- 获取路径参数
local id = ngx.var[1]

-- 封装查询函数
function read_data(key, path, params, method)
    -- 查询redis
    -- local resp = read_redis("192.168.43.33", 6381, key)
    local resp = read_redis_cluster(key)
    -- 判断查询结果
    if not resp then
        ngx.log(ngx.ERR, "redis查询失败, 尝试查询http, key: ", key)
        -- redis 查询失败, 去查询http
        resp = read_http(path, params, method)
    end
    return resp
end

-- 查询商品信息
local itemJson = read_data("item:id:" .. id, "/items/" .. id, nil, ngx.HTTP_GET)
-- 查询库存信息
local stockJson = read_data("item:stock:id:" .. id, "/items/stock/" .. id, nil, ngx.HTTP_GET)

-- JSON 转化为lua的table
local item = cjson.decode(itemJson)
local stock = cjson.decode(stockJson)

-- 组合数据
item.stock = stock.stock
item.sold = stock.sold

-- 把item序列化为json, 返回结果
ngx.say(cjson.encode(item))
``````



#### (7). Nginx本地缓存

![image-20231113171036898](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231113171036898.png)

**需求:**

- 修改item.lua中的read_data函数, 优先查询本地缓存, 未命中时再查询Redis, Tomcat
- 查询Redis或Tomcat成功后, 将数据写入本地缓存, 并设置有效期
- 商品基本信息, 有效期30分钟
- 库存信息, 有效期1分钟

``````lua
-- 封装查询函数
function read_data(key, expire, path, params, method)
    -- 查询本地缓存
    local val = item_cache:get(key)
    if not val then
        ngx.log(ngx.ERR, "本地缓存查询失败, 尝试查询redis, key: ", key)
        -- 查询redis
        -- local resp = read_redis("192.168.43.33", 6381, key)
        local resp = read_redis_cluster(key)
        -- 判断查询结果
        if not resp then
            ngx.log(ngx.ERR, "redis查询失败, 尝试查询http, key: ", key)
            -- redis 查询失败, 去查询http
            resp = read_http(path, params, method)
        end
        val = resp
    end
    -- 查询成功, 把数据写入本地缓存
    item_cache:set(key, val, expire)
    -- 返回数据
    return val
end
``````



### 4. 缓存同步策略

### (1). 数据同步策略

缓存数据同步的常见方式有三种:

- 设置有效期: 给缓存设置有效期, 到期后自动删除. 再次查询时更新
    - 优势: 简单, 方便
    - 缺点: 时效性差, 缓存过期之前可能不一致
    - 场景: 更新频率较低, 时效性要求低的业务
- 同步双写: 在修改数据库的同时, 直接修改缓存
    - 优势: 时效性强, 缓存与数据库强一致
    - 缺点: 有代码侵入, 耦合度高
    - 场景: 对一致性, 时效性要求较高的缓存数据
- 异步通知: 修改数据库时发送事件通知, 相关服务监听到通知后修改缓存数据
    - 优势: 低耦合, 可以同时通知多个缓存服务
    - 缺点: 时效性一般, 可能存在中间不一致状态
    - 场景: 时效性要求一般, 有多个服务需要同步

### (2). 安装Canal

**Canal**, 翻译为水管/管道/渠道, 是阿里巴巴旗下的一款开源项目, 基于Java开发. 基于数据库增量日志解析, 提供增量数据订阅&消费

Canal是基于mysql的主从同步来实现的, MySQL主从同步的原理如下:

![image-20231113184910625](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231113184910625.png)

Canal就是把自己伪装成MYSQL的一个slave节点, 从而监听master的binary log变化. 再把得到的变化信息通知给Canal客户端, 进而完成对其他数据库的同步.

![image-20231113185125709](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231113185125709.png)



### (3). 监听Canal

Canal提供了各种语言的客户端, 当Canal监听到binlog变化时, 会通知Canal的客户端.

使用第三方开源的canal-starter

引入依赖:

``````xml
<!-- https://mvnrepository.com/artifact/top.javatool/canal-spring-boot-starter -->
<dependency>
    <groupId>top.javatool</groupId>
    <artifactId>canal-spring-boot-starter</artifactId>
    <version>1.2.1-RELEASE</version>
</dependency>

``````

springboot配置:

``````yaml
# canal配置
canal:
  destination: prod # 集群名称
  server: 192.168.43.33:11111
``````

![image-20231113200732481](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231113200732481.png)

![image-20231113200910965](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231113200910965.png)

编写监听器, 监听Canal消息:

``````java
@CanalTable("tb_item")
@Component
@Slf4j
public class ItemHandler implements EntryHandler<Item> {

    @Resource
    private RedisHandler redisHandler;

    @Resource
    private Cache<Long, Item> itemCache;

    /**
     * Description: insert 发生数据插入
     * @return void
     * @author jinhui-huang
     * @Date 2023/11/13
     * */
    @Override
    public void insert(Item item) {
        log.info("发生数据插入");
        /*写数据到JVM进程缓存*/
        itemCache.put(item.getId(), item);
        /*写数据到redis*/
        redisHandler.saveItem(item);
    }

    /**
     * Description: update 发生数据更新
     * @return void
     * @author jinhui-huang
     * @Date 2023/11/13
     * */
    @Override
    public void update(Item before, Item after) {
        log.info("发生数据更新");
        /*写数据到JVM进程缓存*/
        itemCache.put(after.getId(), after);
        /*写数据到redis*/
        redisHandler.saveItem(after);
    }

    /**
     * Description: delete 发生数据删除
     * @return void
     * @author jinhui-huang
     * @Date 2023/11/13
     * */
    @Override
    public void delete(Item item) {
        log.info("发生数据删除");
        /*删除JVM进程数据*/
        itemCache.invalidate(item.getId());
        /*删除redis数据*/
        redisHandler.deleteItem(item);
    }
}

``````



### (4). 缓存同步总结

- 已有问题:
    - 由于Canal客户端在一台服务器监听到mysql数据发生变化后, 其他服务器上的Canak客户端就监听不到了, 而且Caffiene多进程下也无法跨服务器实现进程缓存同时更新, 导致不同服务器下的进程缓存不同同时实时更新.
    - Canal-Server无法把数据库的更新通知到openresty, 导致openresty的本地缓存无法直接更新
- 解决方案
    - Canal直接把数据库的更新发送的消息队列mq中去, Openresty和Caffeine充当消费者直接完成数据的更新

![image-20231114145133414](https://raw.githubusercontent.com/Jinhui-Huang/jedis-demo/master/src/main/resources/img/image-20231114145133414.png)

